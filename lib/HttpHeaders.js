/**
 * @auto-generated
 * generator: build/generateHttpHeaders.js
 *
 * DO NOT EDIT THIS FILE DIRECTLY.
 */

"use strict";

const MediaType = require("./MediaType");

/**
 * @typedef {{parameter: string, q: number}[]} Negotiation
 * @typedef {{directive: string, seconds: number}} CacheControl
 * @typedef {{unit: string, ranges: ({start: number, end: number}|{start:number}|{end:number})[]}} Ranges
 * @typedef {{unit: string, start: number, end: number, size: number}} ContentRange
 * @typedef {{weak: boolean, tag: string}} ETag
 * @typedef {{directive: string, sources: string[]}[]} CSP
 * @typedef {{directive: string, allowlist: string[]}[]} FeaturePolicy
 * @typedef {MediaType} MediaType
 */

const INVALID_DATE = new Date(NaN);
const HTTP_DATE_RE = /^(?<dayName>Mon|Tue|Wed|Thu|Fri|Sat|Sun), (?<day>0[1-9]|[1-9][0-9]) (?<month>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (?<year>[1-9][0-9{3,}) (?<hour>[0-9]{2}):(?<minute>[0-9]{2}):(?<second>[0-9]{2}) GMT$/;

/**
 * @param {string} string
 * @return {Date}
 */
const parseHttpDate = string => {
	const match = string.match(HTTP_DATE_RE);
	if (match == null) return INVALID_DATE;
	return new Date(
		parseInt(match.groups.year, 10),
		parseInt(match.groups.month, 10) - 1,
		parseInt(match.groups.day, 10),
		parseInt(match.groups.hour, 10),
		parseInt(match.groups.minute, 10),
		parseInt(match.groups.second, 10)
	);
}

/** @type {Map<string,string>} */
const NORMAL_MAP = new Map([
	["accept-charset", "acceptCharset"],
	["accept-datetime", "acceptDatetime"],
	["accept-encoding", "acceptEncoding"],
	["accept-language", "acceptLanguage"],
	["accept-patch", "acceptPatch"],
	["accept-ranges", "acceptRanges"],
	["access-control-allow-credentials", "accessControlAllowCredentials"],
	["access-control-allow-headers", "accessControlAllowHeaders"],
	["access-control-allow-methods", "accessControlAllowMethods"],
	["access-control-allow-origin", "accessControlAllowOrigin"],
	["access-control-expose-headers", "accessControlExposeHeaders"],
	["access-control-max-age", "accessControlMaxAge"],
	["accept-control-request-method", "acceptControlRequestMethod"],
	["accept-control-request-headers", "acceptControlRequestHeaders"],
	["alt-svc", "altSvc"],
	["cache-control", "cacheControl"],
	["content-disposition", "contentDisposition"],
	["content-encoding", "contentEncoding"],
	["content-language", "contentLanguage"],
	["content-length", "contentLength"],
	["content-location", "contentLocation"],
	["content-range", "contentRange"],
	["content-security-policy", "contentSecurityPolicy"],
	["content-type", "contentType"],
	["expect-ct", "expectCt"],
	["feature-policy", "featurePolicy"],
	["if-match", "ifMatch"],
	["if-modified-since", "ifModifiedSince"],
	["if-none-match", "ifNoneMatch"],
	["if-range", "ifRange"],
	["if-unmodified-since", "ifUnmodifiedSince"],
	["last-modified", "lastModified"],
	["max-forwards", "maxForwards"],
	["proxy-authenicate", "proxyAuthenicate"],
	["proxy-authorization", "proxyAuthorization"],
	["retry-after", "retryAfter"],
	["save-data", "saveData"],
	["set-cookie", "setCookie"],
	["strict-transport-security", "strictTransportSecurity"],
	["timing-allow-origin", "timingAllowOrigin"],
	["upgrade-insecure-requests", "upgradeInsecureRequests"],
	["user-agent", "userAgent"],
	["www-authenticate", "wwwAuthenticate"],
	["x-content-type-options", "xContentTypeOptions"],
	["x-requested-with", "xRequestedWith"]
]);

const REVERSE_MAP = new Map;
for (const [a, b] of NORMAL_MAP) REVERSE_MAP.set(b, a);

const mapName = name => {
	const lower = name.toLowerCase();
	return NORMAL_MAP.has(lower) ? NORMAL_MAP.get(lower) : lower;
};

/** @type {Set<string>} */
const DISCARD_DUPLICATES = new Set([
	"accessControlAllowCredentials",
	"accessControlMaxAge",
	"acceptControlRequestMethod",
	"age",
	"authorization",
	"contentEncoding",
	"contentLanguage",
	"contentLength",
	"contentLocation",
	"contentRange",
	"contentType",
	"date",
	"dnt",
	"etag",
	"expires",
	"from",
	"ifMatch",
	"ifModifiedSince",
	"ifNoneMatch",
	"ifRange",
	"ifUnmodifiedSince",
	"lastModified",
	"location",
	"maxForwards",
	"proxyAuthorization",
	"range",
	"referer",
	"retryAfter",
	"tk",
	"upgradeInsecureRequests",
	"userAgent",
	"xContentTypeOptions"
]);

class HttpHeaders  {
	/** @type {Map<string,string>} */
	unknownHeaders = new Map;
	/** @type {Set<string>} */
	hset = new Set;

	/** @type {CacheControl} */
	cacheControl;
	/** @type {string} */
	connection = "";
	/** @type {number} */
	contentLength;
	/** @type {MediaType} */
	contentType;
	/** @type {Date} */
	date;
	/** @type {string} */
	via = "";
	/** @type {string} */
	warning = "";

	/**
	 * @param {string[]} rawHeaders
	 */
	constructor(rawHeaders = []) {
		for (let i = 0; i < rawHeaders.length; i += 2) {
			this.add(rawHeaders[i], rawHeaders[i | 1]);
		}
	}

	/**
	 * @param {string} name
	 * @param {string} value
	 */
	add(name, value) {
		name = mapName(name);

		if (DISCARD_DUPLICATES.has(name) && this.hset.has(name)) return;
		this.hset.add(name);

		switch (name) {
			case "cacheControl": {
				
				return;
			}
			case "connection":
			case "via":
			case "warning": {
				this[name] += (this[name] !== "" ? "," : "") + value;
				return;
			}
			case "contentLength": {
				this[name] = parseInt(value, 10);
				return;
			}
			case "contentType": {
				this[name] = MediaType.fromString(value);
				return;
			}
			case "date": {
				this[name] = parseHttpDate(value);
				return;
			}
		}
		
		const oldValue = this.unknownHeaders.has(name) ? this.unknownHeaders.get(name) : "";
		const addComma = oldValue.length === 0 || !oldValue.endsWith(",");

		this.unknownHeaders.set(name, oldValue + (addComma ? "," : "") + value);
	}
}

class ResponseHeaders extends HttpHeaders {
	/** @type {string[]} */
	acceptPatch = [];
	/** @type {string} */
	acceptRanges = "";
	/** @type {boolean} */
	accessControlAllowCredentials;
	/** @type {string[]} */
	accessControlAllowHeaders = [];
	/** @type {string[]} */
	accessControlAllowMethods = [];
	/** @type {string} */
	accessControlAllowOrigin = "";
	/** @type {string[]} */
	accessControlExposeHeaders = [];
	/** @type {number} */
	accessControlMaxAge;
	/** @type {number} */
	age;
	/** @type {string[]} */
	allow = [];
	/** @type {string} */
	altSvc = "";
	/** @type {string} */
	contentDisposition = "";
	/** @type {string} */
	contentEncoding = "";
	/** @type {string[]} */
	contentLanguage = [];
	/** @type {string} */
	contentLocation = "";
	/** @type {ContentRange} */
	contentRange;
	/** @type {CSP} */
	contentSecurityPolicy;
	/** @type {ETag} */
	etag;
	/** @type {string} */
	expectCt = "";
	/** @type {Date} */
	expires;
	/** @type {FeaturePolicy} */
	featurePolicy;
	/** @type {Date} */
	lastModified;
	/** @type {string[]} */
	link = [];
	/** @type {string} */
	location = "";
	/** @type {string} */
	proxyAuthenicate = "";
	/** @type {string} */
	refresh = "";
	/** @type {string} */
	retryAfter = "";
	/** @type {string} */
	server = "";
	/** @type {string[]} */
	setCookie = [];
	/** @type {string} */
	strictTransportSecurity = "";
	/** @type {string[]} */
	timingAllowOrigin = [];
	/** @type {string} */
	tk = "";
	/** @type {string[]} */
	vary = [];
	/** @type {string} */
	wwwAuthenticate = "";
	/** @type {string} */
	xContentTypeOptions = "nosniff";

	/**
	 * @param {string} name
	 * @param {string} value
	 */
	add(name, value) {
		name = mapName(name);

		if (DISCARD_DUPLICATES.has(name) && this.hset.has(name)) return;
		this.hset.add(name);

		switch (name) {
			case "acceptPatch":
			case "accessControlAllowHeaders":
			case "accessControlAllowMethods":
			case "accessControlExposeHeaders":
			case "allow":
			case "contentLanguage":
			case "link":
			case "setCookie":
			case "timingAllowOrigin":
			case "vary": {
				this[name].push(...value.split(/ *, */g).filter(s => s.length));
				return;
			}
			case "acceptRanges":
			case "accessControlAllowOrigin":
			case "altSvc":
			case "contentDisposition":
			case "contentEncoding":
			case "contentLocation":
			case "expectCt":
			case "location":
			case "proxyAuthenicate":
			case "refresh":
			case "retryAfter":
			case "server":
			case "strictTransportSecurity":
			case "tk":
			case "wwwAuthenticate":
			case "xContentTypeOptions": {
				this[name] += (this[name] !== "" ? "," : "") + value;
				return;
			}
			case "accessControlAllowCredentials": {
				this[name] = value === "true";
				return;
			}
			case "accessControlMaxAge":
			case "age": {
				this[name] = parseInt(value, 10);
				return;
			}
			case "contentRange": {
				
				return;
			}
			case "contentSecurityPolicy": {
				
				return;
			}
			case "etag": {
				
				return;
			}
			case "expires":
			case "lastModified": {
				this[name] = parseHttpDate(value);
				return;
			}
			case "featurePolicy": {
				
				return;
			}
		}
		
		super.add(name, value);
	}
}

class RequestHeaders extends HttpHeaders {
	/** @type {Negotiation} */
	accept;
	/** @type {Negotiation} */
	acceptCharset;
	/** @type {Date} */
	acceptDatetime;
	/** @type {Negotiation} */
	acceptEncoding;
	/** @type {Negotiation} */
	acceptLanguage;
	/** @type {string} */
	acceptControlRequestMethod = "";
	/** @type {string[]} */
	acceptControlRequestHeaders = [];
	/** @type {string} */
	authorization = "";
	/** @type {string[]} */
	cookie = [];
	/** @type {boolean} */
	dnt;
	/** @type {string} */
	expect = "";
	/** @type {string} */
	forwarded = "";
	/** @type {string} */
	from = "";
	/** @type {string} */
	host = "";
	/** @type {string} */
	ifMatch = "";
	/** @type {Date} */
	ifModifiedSince;
	/** @type {string} */
	ifNoneMatch = "";
	/** @type {string} */
	ifRange = "";
	/** @type {Date} */
	ifUnmodifiedSince;
	/** @type {number} */
	maxForwards;
	/** @type {string} */
	origin = "";
	/** @type {string} */
	proxyAuthorization = "";
	/** @type {Ranges} */
	range;
	/** @type {string} */
	referer = "";
	/** @type {boolean} */
	saveData;
	/** @type {Negotiation} */
	te;
	/** @type {boolean} */
	upgradeInsecureRequests;
	/** @type {string} */
	userAgent = "";
	/** @type {string} */
	xRequestedWith = "";

	/**
	 * @param {string} name
	 * @param {string} value
	 */
	add(name, value) {
		name = mapName(name);

		if (DISCARD_DUPLICATES.has(name) && this.hset.has(name)) return;
		this.hset.add(name);

		switch (name) {
			case "accept":
			case "acceptCharset":
			case "acceptEncoding":
			case "acceptLanguage":
			case "te": {
				
				return;
			}
			case "acceptDatetime":
			case "ifModifiedSince":
			case "ifUnmodifiedSince": {
				this[name] = parseHttpDate(value);
				return;
			}
			case "acceptControlRequestMethod":
			case "authorization":
			case "expect":
			case "forwarded":
			case "from":
			case "host":
			case "ifMatch":
			case "ifNoneMatch":
			case "ifRange":
			case "origin":
			case "proxyAuthorization":
			case "referer":
			case "userAgent":
			case "xRequestedWith": {
				this[name] += (this[name] !== "" ? "," : "") + value;
				return;
			}
			case "acceptControlRequestHeaders": {
				this[name].push(...value.split(/ *, */g).filter(s => s.length));
				return;
			}
			case "cookie": {
				this[name].push(...value.split(/ *; */g).filter(s => s.length));
				return;
			}
			case "dnt":
			case "upgradeInsecureRequests": {
				this[name] = value === "1";
				return;
			}
			case "maxForwards": {
				this[name] = parseInt(value, 10);
				return;
			}
			case "range": {
				
				return;
			}
			case "saveData": {
				this[name] = value === "on";
				return;
			}
		}
		
		super.add(name, value);
	}
}

module.exports = {
	HttpHeaders,
	ResponseHeaders,
	RequestHeaders,
	INVALID_DATE
};
